// This file is auto-generated. Do not edit this file manually.
// To regenerate the schema, run:
// `npx @better-auth/cli generate --output undefined -y`

import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
import { nests } from "./schemas/nests";
import { user } from "./schemas/user";

const Attachment = v.object({
	contentType: v.string(), // MIME type
	description: v.union(v.null(), v.string()), // Description
	ephemeral: v.boolean(), // Whether the attachment is ephemeral
	height: v.optional(v.number()), // Height in pixels
	width: v.optional(v.number()), // Width in pixels
	id: v.id("storage"), // Storage ID
	size: v.number(), // Size in bytes
	spoiler: v.boolean(), // Whether the attachment is a spoiler
	url: v.string(), // Public URL
});

const Message = v.object({
	inGuild: v.optional(v.boolean()),
	attachments: v.optional(v.array(v.id("attachments"))),
	authorId: v.id("user"),
	channelId: v.id("channel"),
	content: v.string(),
	createdAt: v.string(),
	createdTimestamp: v.number(),
	editedAt: v.optional(v.string()),
	guildId: v.optional(v.id("guild")),
	id: v.string(),
	nonce: v.optional(v.string()),
	position: v.optional(v.number()),
	referencedMessage: v.optional(
		v.union(v.null(), v.id("messages"), v.id("channel"), v.id("guild")),
	),
	url: v.optional(v.string()),
})

export const tables = {
	...user,
	...nests,
	messages: defineTable(Message)
		.index("channelId", ["channelId"])
		.index("channelId_createdTimestamp", ["channelId", "createdTimestamp"])
		.index("authorId", ["authorId"])
		.index("guildId", ["guildId"]),
	attachments: defineTable(Attachment),
	session: defineTable({
		expiresAt: v.number(),
		token: v.string(),
		createdAt: v.number(),
		updatedAt: v.number(),
		ipAddress: v.optional(v.union(v.null(), v.string())),
		userAgent: v.optional(v.union(v.null(), v.string())),
		userId: v.string(),
	})
		.index("expiresAt", ["expiresAt"])
		.index("expiresAt_userId", ["expiresAt", "userId"])
		.index("token", ["token"])
		.index("userId", ["userId"]),
	account: defineTable({
		accountId: v.string(),
		providerId: v.string(),
		userId: v.string(),
		accessToken: v.optional(v.union(v.null(), v.string())),
		refreshToken: v.optional(v.union(v.null(), v.string())),
		idToken: v.optional(v.union(v.null(), v.string())),
		accessTokenExpiresAt: v.optional(v.union(v.null(), v.number())),
		refreshTokenExpiresAt: v.optional(v.union(v.null(), v.number())),
		scope: v.optional(v.union(v.null(), v.string())),
		password: v.optional(v.union(v.null(), v.string())),
		createdAt: v.number(),
		updatedAt: v.number(),
	})
		.index("accountId", ["accountId"])
		.index("accountId_providerId", ["accountId", "providerId"])
		.index("providerId_userId", ["providerId", "userId"])
		.index("userId", ["userId"]),
	verification: defineTable({
		identifier: v.string(),
		value: v.string(),
		expiresAt: v.number(),
		createdAt: v.number(),
		updatedAt: v.number(),
	})
		.index("expiresAt", ["expiresAt"])
		.index("identifier", ["identifier"]),
	jwks: defineTable({
		publicKey: v.string(),
		privateKey: v.string(),
		createdAt: v.number(),
	}),
	olmAccount: defineTable({
		userId: v.string(),
		identityKey: v.object({
			curve25519: v.string(),
			ed25519: v.string(),
		}),
		oneTimeKeys: v.array(v.object({
			keyId: v.string(),
			publicKey: v.string(),
		})),
		createdAt: v.optional(v.number()),
		updatedAt: v.optional(v.number()),
		keyVersion: v.optional(v.number()), // Increments when keys are rotated
	})
		.index("userId", ["userId"])
		.index("userId_keys", ["userId", "oneTimeKeys"])
		.index("userId_identityKey", ["userId", "identityKey"]),
};

const schema = defineSchema(tables);

export default schema;
